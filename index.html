<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Delinho - Hora da Conversa</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Baloo+2:wght@500;700;800&display=swap");

    :root {
      --sky: #dff5ff;
      --sun: #fff2c4;
      --card: #ffffff;
      --title: #1a3b5d;
      --text: #335670;
      --ok: #2b9a7a;
      --danger: #e2535d;
      --main: #0e9db3;
      --main-2: #2fb8c9;
      --shadow: 0 18px 40px rgba(26, 59, 93, 0.18);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Baloo 2", system-ui, sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 20% 15%, var(--sun) 0%, transparent 34%),
        radial-gradient(circle at 80% 10%, #ffd7eb 0%, transparent 28%),
        linear-gradient(145deg, var(--sky), #f8faff);
      display: grid;
      place-items: center;
      padding: 16px;
    }

    .card {
      width: min(100%, 520px);
      background: var(--card);
      border-radius: 26px;
      border: 2px solid #dbeefd;
      box-shadow: var(--shadow);
      padding: 22px;
    }

    .top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .mascot {
      width: 58px;
      height: 58px;
      flex: 0 0 58px;
      filter: drop-shadow(0 6px 10px rgba(26, 59, 93, 0.18));
      animation: bob 2.6s ease-in-out infinite;
    }

    h1 {
      margin: 0;
      font-size: 2.2rem;
      color: var(--title);
      line-height: 1.05;
    }

    .status-pill {
      padding: 8px 12px;
      border-radius: 999px;
      font-weight: 800;
      font-size: 0.9rem;
      background: #fff2ef;
      color: #c24747;
    }

    .status-box {
      margin-top: 14px;
      border: 2px dashed #cde4f7;
      border-radius: 14px;
      padding: 10px 12px;
      background: #f5fbff;
      font-size: 1.05rem;
      font-weight: 700;
    }

    .hint {
      margin: 12px 0 14px;
      font-size: 1rem;
    }

    .talk-btn {
      width: 100%;
      border: 0;
      border-radius: 18px;
      padding: 16px 14px;
      background: linear-gradient(130deg, var(--main), var(--main-2));
      color: #fff;
      font: inherit;
      font-size: 1.2rem;
      font-weight: 800;
      cursor: pointer;
      box-shadow: 0 10px 22px rgba(14, 157, 179, 0.35);
      transition: transform .15s ease, filter .2s ease;
    }

    .talk-btn:hover { filter: brightness(1.05); }
    .talk-btn:active { transform: scale(0.99); }
    .talk-btn:disabled {
      cursor: not-allowed;
      background: #a5bcc8;
      box-shadow: none;
    }

    .talk-btn.recording {
      background: linear-gradient(130deg, var(--danger), #ff7a83);
      animation: pulse 1.1s infinite;
    }

    .answer {
      margin-top: 14px;
      border-radius: 14px;
      background: #fffdf3;
      border: 2px solid #ffe9a9;
      color: #5a4e26;
      min-height: 56px;
      padding: 10px 12px;
      display: none;
      font-weight: 700;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.03); }
    }

    @keyframes bob {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-4px); }
    }

    .eye {
      transform-origin: center;
      animation: blink 4.2s infinite;
    }

    @keyframes blink {
      0%, 45%, 47%, 100% { transform: scaleY(1); }
      46% { transform: scaleY(0.1); }
    }

    @media (max-width: 560px) {
      .card { padding: 16px; border-radius: 20px; }
      h1 { font-size: 1.9rem; }
      .talk-btn { font-size: 1.1rem; }
    }
  </style>
</head>
<body>
  <main class="card">
    <div class="top">
      <div class="brand">
        <svg class="mascot" viewBox="0 0 64 64" aria-hidden="true">
          <defs>
            <linearGradient id="mHead" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0%" stop-color="#20c3d8"/>
              <stop offset="100%" stop-color="#0e8ca5"/>
            </linearGradient>
          </defs>
          <rect x="8" y="10" width="48" height="44" rx="14" fill="url(#mHead)"/>
          <circle cx="20" cy="8" r="4" fill="#7bdff2"/>
          <circle cx="44" cy="8" r="4" fill="#7bdff2"/>
          <line x1="20" y1="12" x2="20" y2="9" stroke="#7bdff2" stroke-width="2" />
          <line x1="44" y1="12" x2="44" y2="9" stroke="#7bdff2" stroke-width="2" />
          <circle class="eye" cx="24" cy="30" r="4" fill="#fff"/>
          <circle class="eye" cx="40" cy="30" r="4" fill="#fff"/>
          <path d="M22 42c2.8 3.2 6 4.8 10 4.8s7.2-1.6 10-4.8" fill="none" stroke="#fff" stroke-width="3.8" stroke-linecap="round"/>
        </svg>
        <h1>Delinho</h1>
      </div>
      <span id="connBadge" class="status-pill">Conectando</span>
    </div>

    <div id="status" class="status-box">Preparando tudo...</div>
    <p class="hint">Segure o botão para falar e solte para ouvir a resposta.</p>
    <button id="btn" class="talk-btn" disabled>Aperte e fale</button>
    <div id="response" class="answer"></div>
  </main>

  <script>
    const statusLabel = document.getElementById("status");
    const responseLabel = document.getElementById("response");
    const connBadge = document.getElementById("connBadge");
    const btn = document.getElementById("btn");

    let ws;
    let recordContext;
    let playContext;
    let stream;
    let source;
    let workletNode;
    let isRecording = false;
    let isConnected = false;
    let nextPlayTime = 0;

    function setStatus(text) {
      statusLabel.textContent = text;
    }

    function setConnectionState(connected) {
      isConnected = connected;
      btn.disabled = !connected;
      connBadge.textContent = connected ? "Online" : "Offline";
      connBadge.style.background = connected ? "#e8faef" : "#fff2ef";
      connBadge.style.color = connected ? "#2b9a7a" : "#c24747";
    }

    function connectWS() {
      const protocol = location.protocol === "https:" ? "wss:" : "ws:";
      ws = new WebSocket(`${protocol}//138.185.133.121`);
      ws.binaryType = "arraybuffer";

      ws.onopen = () => {
        setConnectionState(true);
        setStatus("Pronto para conversar");
      };

      ws.onclose = () => {
        setConnectionState(false);
        setStatus("Reconectando em 3 segundos...");
        setTimeout(connectWS, 3000);
      };

      ws.onerror = () => {
        setStatus("Ops! Houve um erro na conexão.");
      };

      ws.onmessage = async (event) => {
        if (typeof event.data === "string") {
          responseLabel.style.display = "block";
          responseLabel.textContent = event.data;
          return;
        }

        const audioData = event.data;
        if (audioData.byteLength > 0) {
          await playAudioChunk(audioData);
        } else {
          nextPlayTime = 0;
          setStatus("Pronto para conversar");
        }
      };
    }

    async function setupRecorderWorklet() {
      const processorCode = `
        class PcmRecorderProcessor extends AudioWorkletProcessor {
          process(inputs) {
            const input = inputs[0];
            if (input && input[0] && input[0].length) {
              this.port.postMessage(input[0]);
            }
            return true;
          }
        }
        registerProcessor('pcm-recorder-processor', PcmRecorderProcessor);
      `;
      const blob = new Blob([processorCode], { type: "application/javascript" });
      const moduleUrl = URL.createObjectURL(blob);
      await recordContext.audioWorklet.addModule(moduleUrl);
      URL.revokeObjectURL(moduleUrl);

      workletNode = new AudioWorkletNode(recordContext, "pcm-recorder-processor");
      workletNode.port.onmessage = (e) => {
        if (!isRecording || !ws || ws.readyState !== WebSocket.OPEN) return;
        const input = e.data;
        const pcm = new Int16Array(input.length);
        for (let i = 0; i < input.length; i++) {
          const s = Math.max(-1, Math.min(1, input[i]));
          pcm[i] = s * 0x7fff;
        }
        ws.send(pcm.buffer);
      };
    }

    async function playAudioChunk(arrayBuffer) {
      if (!playContext) {
        playContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
      }
      await playContext.resume();

      const pcm16 = new Int16Array(arrayBuffer);
      const float32 = new Float32Array(pcm16.length);
      for (let i = 0; i < pcm16.length; i++) {
        float32[i] = pcm16[i] / 32768;
      }

      const audioBuffer = playContext.createBuffer(1, float32.length, 24000);
      audioBuffer.copyToChannel(float32, 0);

      const src = playContext.createBufferSource();
      src.buffer = audioBuffer;
      src.connect(playContext.destination);

      const now = playContext.currentTime;
      if (nextPlayTime === 0) {
        // Pequeno prebuffer para absorver jitter de rede e evitar estalos.
        nextPlayTime = now + 0.08;
      }
      const startTime = Math.max(nextPlayTime, now + 0.02);
      src.start(startTime);
      nextPlayTime = startTime + audioBuffer.duration;
    }

    async function startRecording() {
      if (!isConnected || isRecording || !navigator.mediaDevices?.getUserMedia) return;

      try {
        isRecording = true;
        btn.classList.add("recording");
        btn.textContent = "Gravando... solte para enviar";
        setStatus("Estou ouvindo voce...");
        responseLabel.style.display = "none";

        recordContext = new (window.AudioContext || window.webkitAudioContext)();
        await recordContext.resume();
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        source = recordContext.createMediaStreamSource(stream);
        await setupRecorderWorklet();

        source.connect(workletNode);
        ws.send(JSON.stringify({ type: "config", sampleRate: recordContext.sampleRate }));
      } catch (err) {
        setStatus("Nao consegui acessar o microfone.");
        isRecording = false;
        btn.classList.remove("recording");
        btn.textContent = "Aperte e fale";
      }
    }

    async function stopRecording() {
      if (!isRecording) return;

      isRecording = false;
      btn.classList.remove("recording");
      btn.textContent = "Aperte e fale";
      setStatus("Pensando na resposta...");
      nextPlayTime = 0;

      try {
        if (source) source.disconnect();
        if (workletNode) workletNode.disconnect();
        if (stream) stream.getTracks().forEach((t) => t.stop());
        if (recordContext) await recordContext.close();
      } catch (_) {
      }

      stream = null;
      source = null;
      workletNode = null;
      recordContext = null;

      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send("END");
      }
    }

    btn.addEventListener("mousedown", startRecording);
    btn.addEventListener("mouseup", stopRecording);
    btn.addEventListener("mouseleave", stopRecording);
    btn.addEventListener("touchstart", (e) => {
      e.preventDefault();
      startRecording();
    }, { passive: false });
    btn.addEventListener("touchend", (e) => {
      e.preventDefault();
      stopRecording();
    }, { passive: false });

    connectWS();
  </script>
</body>
</html>
